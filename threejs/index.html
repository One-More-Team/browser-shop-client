<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>cannon.js + three.js physics shooter</title>
    <style>
      html,
      body {
        width: 100%;
        height: 100%;
      }

      body {
        background-color: #ffffff;
        margin: 0;
        overflow: hidden;
        font-family: arial;
      }

      #blocker {
        position: absolute;

        width: 100%;
        height: 100%;

        background-color: rgba(0, 0, 0, 0.5);
      }

      #instructions {
        width: 100%;
        height: 100%;

        display: -webkit-box;
        display: -moz-box;
        display: box;

        -webkit-box-orient: horizontal;
        -moz-box-orient: horizontal;
        box-orient: horizontal;

        -webkit-box-pack: center;
        -moz-box-pack: center;
        box-pack: center;

        -webkit-box-align: center;
        -moz-box-align: center;
        box-align: center;

        color: #ffffff;
        text-align: center;

        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <script src="./lib/three.min.js"></script>
    <script src="./lib/cannon.js"></script>
    <script src="./lib/PointerLockControls.js"></script>
    <script src="./lib/CannonDebugRenderer.js"></script>

    <div id="blocker">
      <div id="instructions">
        <span style="font-size: 40px">Click to play</span>
        <br />
        (W,A,S,D = Move, SPACE = Jump, MOUSE = Look, CLICK = Shoot)
      </div>
    </div>

    <script type="module">
      import { FBXLoader } from "./lib/jsm/loaders/FBXLoader.js";
      var sphereShape,
        sphereBody,
        world,
        physicsMaterial,
        walls = [],
        boxes = [],
        boxMeshes = [],
        debugRenderer = null;
      var camera, scene, renderer;
      var geometry, material, grassMaterial, mesh;
      var controls,
        time = Date.now();
      let textureAssets = {};

      var blocker = document.getElementById("blocker");
      var instructions = document.getElementById("instructions");

      var havePointerLock =
        "pointerLockElement" in document ||
        "mozPointerLockElement" in document ||
        "webkitPointerLockElement" in document;

      if (havePointerLock) {
        var element = document.body;

        var pointerlockchange = function (event) {
          if (
            document.pointerLockElement === element ||
            document.mozPointerLockElement === element ||
            document.webkitPointerLockElement === element
          ) {
            controls.enabled = true;

            blocker.style.display = "none";
          } else {
            controls.enabled = false;

            blocker.style.display = "-webkit-box";
            blocker.style.display = "-moz-box";
            blocker.style.display = "box";

            instructions.style.display = "";
          }
        };

        var pointerlockerror = function (event) {
          instructions.style.display = "";
        };

        // Hook pointer lock state change events
        document.addEventListener(
          "pointerlockchange",
          pointerlockchange,
          false
        );
        document.addEventListener(
          "mozpointerlockchange",
          pointerlockchange,
          false
        );
        document.addEventListener(
          "webkitpointerlockchange",
          pointerlockchange,
          false
        );

        document.addEventListener("pointerlockerror", pointerlockerror, false);
        document.addEventListener(
          "mozpointerlockerror",
          pointerlockerror,
          false
        );
        document.addEventListener(
          "webkitpointerlockerror",
          pointerlockerror,
          false
        );

        instructions.addEventListener(
          "click",
          function (event) {
            instructions.style.display = "none";

            // Ask the browser to lock the pointer
            element.requestPointerLock =
              element.requestPointerLock ||
              element.mozRequestPointerLock ||
              element.webkitRequestPointerLock;

            if (/Firefox/i.test(navigator.userAgent)) {
              var fullscreenchange = function (event) {
                if (
                  document.fullscreenElement === element ||
                  document.mozFullscreenElement === element ||
                  document.mozFullScreenElement === element
                ) {
                  document.removeEventListener(
                    "fullscreenchange",
                    fullscreenchange
                  );
                  document.removeEventListener(
                    "mozfullscreenchange",
                    fullscreenchange
                  );

                  element.requestPointerLock();
                }
              };

              document.addEventListener(
                "fullscreenchange",
                fullscreenchange,
                false
              );
              document.addEventListener(
                "mozfullscreenchange",
                fullscreenchange,
                false
              );

              element.requestFullscreen =
                element.requestFullscreen ||
                element.mozRequestFullscreen ||
                element.mozRequestFullScreen ||
                element.webkitRequestFullscreen;

              element.requestFullscreen();
            } else {
              element.requestPointerLock();
            }
          },
          false
        );
      } else {
        instructions.innerHTML =
          "Your browser doesn't seem to support Pointer Lock API";
      }

      initCannon();
      init();

      var textureLoader = new THREE.TextureLoader();
      var textureEquirec = textureLoader.load(
        "asset/texture/autumn_park_2k.jpg"
      );
      textureEquirec.mapping = THREE.EquirectangularReflectionMapping;
      textureEquirec.encoding = THREE.sRGBEncoding;
      var geometry = new THREE.IcosahedronBufferGeometry(400, 15);
      var sphereMaterial = new THREE.MeshLambertMaterial({
        envMap: textureEquirec,
      });
      var sphereMesh = new THREE.Mesh(geometry, sphereMaterial);
      scene.add(sphereMesh);
      scene.background = textureEquirec;

      debugRenderer = new THREE.CannonDebugRenderer(scene, world);

      function initCannon() {
        // Setup our world
        world = new CANNON.World();
        world.quatNormalizeSkip = 0;
        world.quatNormalizeFast = false;

        var solver = new CANNON.GSSolver();

        world.defaultContactMaterial.contactEquationStiffness = 1e9;
        world.defaultContactMaterial.contactEquationRelaxation = 4;

        solver.iterations = 7;
        solver.tolerance = 0.1;
        var split = true;
        if (split) world.solver = new CANNON.SplitSolver(solver);
        else world.solver = solver;

        world.gravity.set(0, -20, 0);
        world.broadphase = new CANNON.NaiveBroadphase();

        // Create a slippery material (friction coefficient = 0.0)
        physicsMaterial = new CANNON.Material("slipperyMaterial");
        var physicsContactMaterial = new CANNON.ContactMaterial(
          physicsMaterial,
          physicsMaterial,
          0.0, // friction coefficient
          0.3 // restitution
        );
        // We must add the contact materials to the world
        world.addContactMaterial(physicsContactMaterial);

        // Create a sphere
        var mass = 5,
          radius = 1.3;
        sphereShape = new CANNON.Sphere(radius);
        sphereBody = new CANNON.Body({ mass: mass });
        sphereBody.addShape(sphereShape);
        sphereBody.position.set(40, 0.5, 10);
        sphereBody.linearDamping = 0.9;
        world.add(sphereBody);
        //sphereBody.rotation.y = Math.PI / 2;

        var groundShape = new CANNON.Plane();
        var groundBody = new CANNON.Body({ mass: 0 });
        groundBody.addShape(groundShape);
        groundBody.quaternion.setFromAxisAngle(
          new CANNON.Vec3(1, 0, 0),
          -Math.PI / 2
        );
        world.add(groundBody);
      }

      function init() {
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );

        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 0, 500);

        var ambient = new THREE.AmbientLight(0x111111);
        scene.add(ambient);

        var alight = new THREE.AmbientLight(0xffffff); // soft white light
        scene.add(alight);

        let light = new THREE.SpotLight(0xffffff);
        light.position.set(10, 30, 20);
        light.target.position.set(0, 0, 0);
        if (true) {
          light.castShadow = true;

          light.shadow.camera.near = 20;
          light.shadow.camera.far = 50; //camera.far;
          light.shadow.camera.fov = 40;

          //light.shadowMapBias = 0.1;
          //light.shadowMapDarkness = 0.7;
          light.shadow.mapSize.width = 2 * 512;
          light.shadow.mapSize.height = 2 * 512;

          //light.shadowCameraVisible = true;
        }
        /* scene.add(light); */

        controls = new PointerLockControls(camera, sphereBody);
        scene.add(controls.getObject());

        const loadTextures = (textureConfig, onLoaded) => {
          const currentConfig = textureConfig[0];
          console.log(
            `Load texture asset ${currentConfig.id} from: ${currentConfig.url}`
          );
          new THREE.TextureLoader().load(currentConfig.url, (texture) => {
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(currentConfig.scaleX, currentConfig.scaleY);
            texture.rotation = currentConfig.rotation;
            textureAssets = {
              ...textureAssets,
              [currentConfig.id]: new THREE.MeshBasicMaterial({
                map: texture,
              }),
            };
            if (textureConfig.length > 1) {
              textureConfig.shift();
              loadTextures(textureConfig, onLoaded);
            } else onLoaded();
          });
        };
        const textures = [
          {
            url: "./asset/3d/texture/aerial_grass_rock_diff_1k.jpg",
            id: "GrassL",
            scaleX: 100,
            scaleY: 100,
            rotation: 0,
          },
          {
            url: "./asset/3d/texture/factory_brick_diff_1k.jpg",
            id: "Bricks",
            scaleX: 40,
            scaleY: 10,
            rotation: Math.PI / 2,
          },
          {
            url: "./asset/3d/texture/marble_01_diff_1k.jpg",
            id: "Floor",
            scaleX: 1,
            scaleY: 1,
          },
          {
            url: "./asset/3d/texture/large_square_pattern_01_diff_1k.jpg",
            id: "Square",
            scaleX: 1,
            scaleY: 1,
          },
        ];
        loadTextures(textures, () => {
          var loader = new FBXLoader();

          loader.load("./asset/3d/shop.fbx", function (object) {
            /* var mixer = new THREE.AnimationMixer(object);

          var action = mixer.clipAction(object.animations[0]);
          action.play(); */

            object.traverse(function (child) {
              if (child.isMesh) {
                child.castShadow = true;
                child.receiveShadow = true;

                if (child.name.includes("GrassL")) {
                  child.material = textureAssets.GrassL;
                } else if (child.name.includes("Bricks")) {
                  child.material = textureAssets.Bricks;
                } else if (child.name.includes("Floor")) {
                  child.material = textureAssets.Floor;
                } else if (child.name.includes("Square")) {
                  child.material = textureAssets.Square;
                }

                if (child.name.includes("Collider")) {
                  child.castShadow = false;
                  child.receiveShadow = false;
                  const halfExtents = new CANNON.Vec3(
                    child.scale.x / 100,
                    child.scale.y / 100,
                    child.scale.z / 100
                  );
                  console.log(halfExtents);
                  const box = new CANNON.Box(halfExtents);
                  const body = new CANNON.Body({ mass: 0 });
                  body.addShape(box);
                  body.position.copy(
                    new CANNON.Vec3(
                      child.position.x / 100,
                      child.position.y / 100,
                      child.position.z / 100
                    )
                  );
                  body.quaternion.copy(child.quaternion);
                  world.add(body);
                }
              }
            });

            object.scale.set(0.01, 0.01, 0.01);
            scene.add(object);
          });

          material = new THREE.MeshBasicMaterial({ color: 0x555588 });
          let texture = new THREE.TextureLoader().load(
            "./asset/3d/texture/aerial_grass_rock_diff_1k.jpg",
            (texture) => {
              texture.wrapS = THREE.RepeatWrapping;
              texture.wrapT = THREE.RepeatWrapping;
              texture.repeat.set(1, 1);
              material.map = texture;
            }
          );

          renderer = new THREE.WebGLRenderer();
          renderer.shadowMap.enabled = true;
          renderer.shadowMapSoft = true;
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setClearColor(scene.fog.color, 1);

          document.body.appendChild(renderer.domElement);

          window.addEventListener("resize", onWindowResize, false);

          animate();
        });
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      var dt = 1 / 60;
      function animate() {
        requestAnimationFrame(animate);
        if (controls.enabled) {
          world.step(dt);
          /*
          // Update box positions
          for (var i = 0; i < boxes.length; i++) {
            boxMeshes[i].position.copy(boxes[i].position);
            boxMeshes[i].quaternion.copy(boxes[i].quaternion);
          } */
        }

        controls.update(Date.now() - time);
        renderer.render(scene, camera);
        //debugRenderer.update();

        time = Date.now();
      }
    </script>
  </body>
</html>
